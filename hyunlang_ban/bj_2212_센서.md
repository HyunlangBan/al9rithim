### 문제
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.

### 입력
첫째 줄에 센서의 개수 N(1<=N<=10,000), 둘째 줄에 집중국의 개수 K(1<=K<=1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 이상 있으며, 좌표의 절댓값은 1,000,000 이하이다

### 출력
첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.

### 결과 - 실패!
의문 투성이🤔 <br>
일단 풀이 아이디어는 해답과 같았다. 거리를 각각 구한뒤 k에 따라 최대 거리를 제거한다.(=0으로 바꾼다.)<br>
아래는 내가 적었던 코드이다.
```python
import sys
n = int(input())
k = int(input())

sensors = list(map(int, input().split()))
sensors.sort()
sensors = list(set(sensors))

dist = []
for i in range(1, len(sensors)):
    dist.append(sensors[i] - sensors[i - 1])

for i in range(1, len(dist)+1):
    m_i = dist.index(max(dist))
    dist[m_i] = 0
    if i + 1 == k:
        break

print(sum(dist))
``` 
해답에 비하면 지저분하게 풀긴 했지만, 내 눈에 풀이과정은 거의 동일해보인다. k만큼 거리의 합의 갯수가 나오게 하기 위해서는 일단 이어져있는 거리를 끊어주어야 하고(=0으로 바꾸어야하고) 그 거리는 최대가 되어야 하므로 거리의 값을 구한 리스트(`dist`)에서 최대인 값의 인덱스를 구해서 그 값을 0으로 바꿔주었다. <br>그리고 최대 거리를 0으로 바꿔주는 개수를 `i`로 카운트하여 중간 공백의 수 + 1만큼 덩어리(?)를 만들 수 있기 때문에 `i+1 ==k`로 조건을 걸어주었다.<br>
예제는 돌아갔지만 정답 테스트에서 실패했다. 혹시나 `k>=n`인 경우를 안걸러준 것 때문일까 싶어 그 조건을 추가해보아도 실패다. 근데 뭐때문에 틀렸는지를 모르겠다....

### Solution
```python
import sys

n = int(input())
k = int(input())

if k>=n:
    print(0)
    sys.exit()

array = list(map(int, input().split()))

distances = []
for i in range(1, n):
    distances.append(array[i] - array[i-1])
distances.sort(reverse=True)

for i in range(k-1):
    distances[i] = 0
print(sum(distances))
```
### 의문점(반례?)
근데 해설을 보다보니 또 의문점이 생긴다. 내가 문제를 제대로 이해 못한건지 모르겠지만 만약 `n = 5`, `k = 3`, 센서 위치가 `[1, 2, 3, 6, 9]`이라면,
이런 경우에는 거리가 `[1, 1, 3, 3]`이 되기 때문에 거리가 큰 값을 2번 0으로 만들면 `[1,1]`밖에 남지 않고 수신 가능 영역 최소 합이 2가 되는데 그렇게 된다면 `[6,9]` 센서들은  수신국에서 제외된 게 아닌건가? 풀기 전에는 간단한 문제인줄 알았는데 머리가 복잡해졌다.. 일단 당장 해결할 수 있지 않을 것 같아서 백준 질문에 올려두었다. 제발 답변해주시는 분이 있었으면..!

## Review - Solved
### My Code
```python
n = int(input())
k = int(input())
sensors = list(map(int, input().split()))

sensors.sort()
sensors = list(set(sensors))

distances = []
if len(sensors) > 1:
    for i in range(1, len(sensors)):
        distance = sensors[i] - sensors[i - 1]
        distances.append(distance)

    distances.sort()

    for i in range(k - 1):
        distances.pop()

    print(sum(distances))

else:
    print(0)

```
- 문제만 다시 읽었을때는 무슨말이지 했었는데 생각보다 금방 풀었다. 풀이를 기억해내려고 한게 아니고 "합"이라는 키워드를 가지고 자연스럽게 풀이를 해나간 것이 뿌듯했다.😎
- 나는 중복되는 센서 위치는 필요없다고 생각해서 set과 list를 번갈아가면서 사용했지만 distance를 구하는거라서 굳이 없애지 않았어도 됐다.
- 또한 내가 맨 처음에 풀었을때 남겼던 의문점은 오늘의 내가 해결했다.ㅋㅋㅋ
  - 센서위치: `[1, 2, 3, 6, 9]`, 수신국의 수: 3
  - distances = `[1, 1, 3, 3]` 이므로 2개의 연결을 끊어준다.
  - 그리고 가장 크게 오해했던 것이 거리를 없애준다고 해서 그 수신국이 제외되는 것이 아니라 최종적으로 수신국의 개수만큼 덩어리를 만들기 위해서 하는 작업이므로 제외되는 간격 사이 사이에 수신국이 위치하게 되는 것이다. 즉, 1번에 수신 가능 거리가 2인 수신국 1개, 6번에 수신 가능 거리가 0인 수신국 1개, 9번에 수신 가능 거리가 0인 수신국 1개로 총 3개의 수신국을 설치하게 되는 것이다.
